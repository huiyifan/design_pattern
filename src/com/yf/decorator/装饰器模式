
装饰器模式(Decorator)

在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。
在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。

装饰器模式的定义与特点
指在不改变现有对象结构的情况下, 动态地给对象增加一些职责(即增加其额外功能)的模式, 它属于对象结构型模式。

装饰器模式的主要优点:
· 装饰器是继承的有力补充，比继承灵活，在不改变原有对象情况下，动态的给一个对象拓展功能，即插即用。
· 通过使用装饰类及这些装饰类的排列组合，可以实现不同效果
· 装饰器模式完全遵守开闭原则

缺点:
 装饰器模式会增加许多子类, 过度使用会增加程序的复杂性。

 装饰器模式的结构与实现

 通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着拓展功能的增多，子类会很膨胀。
 如果使用组合关系来创建一个包装对象(即装饰对象)来包裹真是对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，
 这就是装饰器模式的目标。下面来分析其基本结构和实现方法。

 一. 模式的结构
 装饰器模式主要包含以下角色。
 1. 抽象构件(Component)角色: 定义一个抽象接口以规范准备接收附加责任的对象。
 2. 具体构件(ConcreteComponent)角色: 实现抽象构件，通过装饰角色为其添加一些职责。
 3. 抽象装饰(Decorator)角色: 继承抽象构件, 并包含具体构件的实例，可以通过其子类扩展具体构建的功能。
 4. 具体装饰(ConcreteDecorator)角色: 实现抽象装饰的相关方法, 并给具体构件对象添加附加的责任。

 二. 模式的实现
 装饰器模式的实现代码如下:




装饰器模式特点在于增强, 它的特点是被装饰类和所有装饰类必须实现同一个接口，而且必须持有被装饰的对象，可以无限装饰。
代理模式的特点在于隔离，隔离调用类和被调用类的关系，通过一个代理类去调用。

总的来说就是如下三句话:
1 适配器模式是将一个类(a) 通过某种方式转换成另一个类(b)。
2 装饰模式是在一个原有类(a) 的基础之上增加了某些新的功能变成另一个类(b)。
3 代理模式是将一个类(a) 转换成具体的操作类(b)。

总结

只需要将原接口转化为客户希望的另一个接口，就是适配器模式。转化无非就是
1.继承原类或者实现原接口
2.持有原接口的对象，再实现目标接口。那么第一种就是类的适配，第二种就是对象的适配。
3.




装饰模式:
· 在不改变接口的前提下, 动态拓展对象的访问。
· 动态继承, 让类具有在运行时期改变行为的能力(来自多态特性)
· 装饰模式, 突出的是运行期增加行为, 这和继承是不同的, 继承是在编译器增加行为
· 强调: 增强.

代理模式:
· 在不改变接口的前提下, 控制对象的访问。
· 从封装的角度讲, 是为了解决类和类之间相互调用而由此导致的耦合关系，可以说是接口的另外一个层引用。
  比如: 在a类 -> b代理 -> c类这个关系中，c类的一切行为都隐藏在b中。即调用者不知道要访问的内容与代理了什么对象。
· 从复用的角度讲，可以解决不同类调用一个复杂类时，仅仅因较小的改变而导致整个复杂类新建一个类。比如:
  a类 -> c类1; b类 -> c类2, 可以变为a类 -> ca代理类 -> c类； b类 -> cb 代理类 -> c类。
· 代理模式, 是类之间的封装和(某方面)的复用。
· 强调限制。
























